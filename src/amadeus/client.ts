import util from "node:util";
import {
  Hostname,
  LogLevel,
  Logger,
  Network,
  Params,
} from "../../@types/amadeus";
import Validator from "./client/validator";
import AccessToken from "./client/accessToken";
import { EventEmitter } from "node:stream";
import { Verb } from "../../@types/amadeus/client";
import pkg from "../../package.json";
import Listener from "./client/listener";
import Request from "./client/request";

/**
 * A convenient wrapper around the API, allowing for generic, authenticated and
 * unauthenticated API calls without having to manage the serialization,
 * desrialization, and authentication.
 *
 * Generally you do not need to use this object directly. Instead it is used
 * indirectly by the various namespaced methods for every API call.
 *
 * For example, the following are the semantically the same.
 *
 * ```js
 * amadeus.client.get('/v1/reference-data/urls/checkin-links', params);
 * amadeus.amadeus.reference_data.urls.checkin_links.get(params);
 * ```
 *
 * @param {Params} options a list of options. See {@link Amadeus} .
 * @property {string} clientId the API key used to authenticate the API
 * @property {string} clientSecret the API secret used to authenticate
 *  the API
 * @property {Logger} logger the `console`-compatible logger used to debug calls
 * @property {LogLevel} logLevel the log level for the client, available options
 *  are `debug`, `warn`, and `silent`. Defaults to 'silent'
 * @property {Hostname} host the hostname of the server API calls are made to
 * @property {number} port the port the server API calls are made to
 * @property {boolean} ssl wether an SSL request is made to the server
 * @property {string} customAppId the custom App ID to be passed in the User
 *  Agent to the server
 * @property {string} customAppVersion the custom App Version number to be
 *  passed in the User Agent to the server
 * @property {Network} http the Node/HTTP(S)-compatible client used to make
 *  requests
 * @property {number} version The version of this API client
 */
class Client implements Params {
  clientId!: string;
  clientSecret!: string;
  customAppId?: string | null;
  customAppVersion?: string | null;
  host!: string;
  hostname!: Hostname;
  http!: Network;
  logLevel!: LogLevel;
  logger!: Logger;
  port!: number;
  ssl!: boolean;
  accessToken!: AccessToken;
  version: string;

  constructor(options: Params) {
    new Validator().validateAndInitialize(this, options);
    this.accessToken = new AccessToken(this);
    this.version = pkg.version;
  }

  /**
   * Make an authenticated API call.
   *
   * ```js
   * amadeus.client.call('GET', '/v2/foo/bar', { some: 'data' });
   * ```
   * @param {string} verb the HTTP method, for example `GET` or `POST`
   * @param {string} path the full path of the API endpoint
   * @param {Object} [params={}] the POST parameters
   * @return {Promise.<Response,ResponseError>} a Promise
   * @protected
   */
  async request(verb: Verb, path: string, params = {}) {
    const bearerToken = await this.accessToken.bearerToken(this);
    return this.unauthenticatedRequest(verb, path, params, bearerToken);
  }

  /**
   * Make any kind of API call, authenticated or not
   *
   * Used by the .get, .post methods to make API calls.
   *
   * Sets up a new Promise and then excutes the API call, triggering the Promise
   * to be called when the API call fails or succeeds.
   *
   * @param {Verb} verb the HTTP method, for example `GET` or `POST`
   * @param {string} path the full path of the API endpoint
   * @param {Object} params the parameters to pass in the query or body
   * @param {string|null} [bearerToken=null] the BearerToken as generated by the
   *  AccessToken class
   * @return {Promise.<Response|ResponseError>} a Promise
   * @public
   */
  public async unauthenticatedRequest<T>(
    verb: Verb,
    path: string,
    params: Object,
    bearerToken: string | null = null
  ): Promise<T> {
    const request = this.buildRequest(verb, path, params, bearerToken);
    this.log(request);
    const emitter = new EventEmitter();
    const promise = this.promise<T>(emitter);

    this.execute(request, emitter);
    return promise;
  }

  /**
   * Actually executes the API call.
   *
   * @param {Request} request the request to execute
   * @param {EventEmitter} emitter the event emitter to notify of changes
   * @private
   */
  private async execute(request: Request, emitter: EventEmitter) {
    const httpRequest = this.http.request(request.options());
    const listener = new Listener(request, emitter, this);
    httpRequest.on("response", listener.onResponse.bind(listener));
    httpRequest.on("error", listener.onError.bind(listener));
    httpRequest.end();
  }

  /**
   * Builds a Request object to be used in the API call
   *
   * @param {Verb} verb the HTTP method, for example `GET` or `POST`
   * @param {string} path the full path of the API endpoint
   * @param {Object} params the parameters to pass in the query or body
   * @param {string|null} [bearerToken=null] the BearerToken as generated by the
   *  AccessToken class
   * @return {Request}
   * @private
   */
  private buildRequest(
    verb: Verb,
    path: string,
    params: any,
    bearerToken: string | null = null
  ) {
    return new Request({
      verb,
      path,
      params,
      bearerToken,
      host: this.host,
      clientVersion: this.version,
      languageVersion: process.versions.node,
      appId: this.customAppId,
      appVersion: this.customAppVersion,
      port: this.port,
      ssl: this.ssl,
    });
  }

  /**
   * Builds a Bluebird Promise to be returned to the API user
   *
   * @param  {type} emitter the event emitter to notify of changes
   * @return {Promise} a Bluebird promise
   * @private
   */
  private promise<T>(emitter: EventEmitter) {
    return new Promise<T>((resolve, reject) => {
      emitter.on("resolve", resolve);
      emitter.on("reject", reject);
    });
  }

  /**
   * Logs the request, when in debug mode
   *
   * @param  {Request} request the request object to log
   * @public
   */
  // change request later
  public log(request: Request) {
    /* istanbul ignore next */
    if (this.debug()) {
      this.logger.log(util.inspect(request, false, null));
    }
  }

  /**
   * Determines if this client is in debug mode
   *
   * @return {boolean}
   */
  public debug(): boolean {
    return this.logLevel == "debug";
  }

  /**
   * Determines if this client is in warn or debug mode
   *
   * @return {boolean}
   */
  public warn(): boolean {
    return this.logLevel == "warn" || this.debug();
  }
}

export default Client;
